## 5장 제어문 : 조건문과 반복문

> 제어문이란 ? 
>
> - **특정 조건**에 따라 **코드의 특정 부분만 수행하거나 반복**이 필요할 때 코드의 **진행 순서를 바꾸는 구문**

### 1. 조건문(if)

1. 조건에 따라 분기하는 if문

- **조건에 따라 코드를 다르게 실행**하려면 **if문**을 이용
- if문에서는 **지정한 조건에 따라 다르게 분기해 명령을 수행**
  - if문에서는 **조건의 만족 여부에 따라서 코드 수행 결과가 달라짐**

2. 단일 조건에 따른 분기(`if ~ else`)

```python
if <조건문> : #조건문 다음엔 반드시 콜론(:)
	<코드블록> #반드시 들여쓰기 ; if의 조건문으로 들어갔다는 것을 의미
"""<조건문>을 만족하면 하단 <코드 블록>을 수행
	만족하지 못한 경우 아무것도 수행하지 않음""""

x = 95
if x >= 90 :
	print("pass")
> pass
x = 80
if x >= 95 :
	print("pass")
> #아무것도 출력되지 않음
```

- **<조건문>**에는 조건을 판단하기 위해 **비교 연산 및 논리 연산**을 이용

- `if~else` 구조의 조건문을 이용하여 만족 여부에 따라 **코드를 다르게 수행 가능**

```python
if <조건문> : #True일 때 실행
	<코드블록1>
else : #False일 때 실행 / 단독으로 else 사용 불가능
	<코드블록2>
#조건문 만족하는 경우 <코드블록1>, 만족하지 못한 경우 <코드블록2> 실행

x = 75
if x > = 90 :
	print('pass')
else :
	print('fail')
> fail
```

3. 여러 조건에 따른 분기(`if ~ elif ~ else`)

- 여러 조건에 따라 코드를 각각 다르게 수행

- `elif`는 필요에 따라 **여러 개** 사용 가능

```python
if <조건문1> : 
	<코드블록1>
elif <조건문2> :
	<코드블록2>
	
elif <조건문n> :
	<코드블록n>
else :
	<코드블록m>
    
"""조건문 만족하는 경우 <코드블록1>, 만족하지 못한 경우 
그 다음 조건문2 검사 후 <코드블록2> 실행/
<조건문2>도 만족하지 못한 경우 그 다음 조건문 검사 후 맞는 코드블록 실행
마지막 조건문까지 만족하지 못한 경우 `else`아래의 <코드블록m>을 실행
else이후는 생략 후`if~elif`만 이용 가능"""

x = 85
if x >= 90 :
    print('참 잘했어요')
elif 80 <= x <90 :
    print('잘했어요')
else : 
    print('탈락입니다')
> 잘했어요
```

4. 중첩 조건에 따른 분기

```python
if <조건문1> : 
	<코드블록1>
	if <조건문 1-1> #중첩 조건문
		<코드블록<1-1>
	else : 
		<코드블록1-2>
		
elif <조건문2> :
	<코드블록2>
else :
	<코드블록m>

""" <조건문1> 만족하는 경우 <조건문1-1>을 만족하는지 검사 후 만족한다면 <코드블록1-1> 수행, 만족하지 못한 경우 <코드블록1-2>
<조건문1>만족하지 못한 경우 그 다음 <조건문2> 검사 후 <코드블록2> 실행/
<조건문2>도 만족하지 못한 경우 그 다음 조건문 검사 후 맞는 코드블록 실행
마지막 <조건문n>까지 만족하지 못한 경우 `else`아래의 <코드블록m>을 실행
else이후는 생략 후`if~elif`만 이용 가능"""

x = 100
if x >= 90 :
    if x == 100 : 
    	print('완벽해요')
    else :
         print('참 잘했어요')
elif 80 <= x <90 :# x=>80 and x<90
    print('잘했어요')
else : 
    print('탈락입니다')
> 완벽해요
```

- if문에 <조건문>을 쓰고 <코드블록>에 아우것도 쓰지 않으면 오류 발생
  - 이 때 **<코드블록>에 pass를 지정**해 if문의 **전체적인 구조를 잡을 수** 있음

```python
if <조건문1> : 
	pass
elif <조건문2> :
	pass
	
elif <조건문n> :
	pass
else :
	pass
```



### 2. 반복문

##### 1. 지정된 범위만큼 반복하는 for문

1. 반복문(for문/while)

- 코드 작성 시 **지정된 횟수만큼 작업 반복 혹은 지정된 조건을 만족하면 작업 반복할 때** 사용
- 작업을 반복적으로 수행하는 구문

2. 반복문의 필요성

- 똑같은 코드를 반복하는 비효율적인 행동을 소거
- **효율적 코드 사용 가능**

3. for문의 구조(혹은 for~in문)

```python
for<반복변수> in <반복범위> : #콜론!!
	<코드블록> #들여쓰기
    
'''<반복변수>는 <반복범위>에 따라 변하면서 <코드블록>을 <반복범위>만큼 실행
<코드블록>에서는 <반복변수> 이용 가능'''
```

4. 반복범위 지정 

- **리스트와 range() 함수**를 이용해 지정
- **리스트 이용 : 숫자열, 문자열 가능**

```python
for i in [1,2,3,4,5] : 
    print(i)
    print(i+10)
>1 #[0] 첫 번째 요소 대입되면서 코드블록 실행
11
2
12
3
13
4
14
5
15 #[4] 마지막 요소 대입되면서 코드블록 마침

myfriend = ['사나','모모','지연'] #리스트를 변수에 할당
for myfriend in myfriend : 
    print(myfriend)
>사나
 모모
 지연
```

- range() 함수 이용
- 파이썬 내장 함수 range() for문에서 **숫자로 <반복범위>를 지정할 때 많이 이용**

- `range(start, stop, step)`
  - start에서 시작해서 stop 전까지(**stop 포함x**) step만큼 계속 더해 <반복 범위>를 만듬
  - start/stop : 양의 정수, 음의 정수,0 
  - step : 양의 정수와 음의 정수 
  -  **start가 0인 경우,  step이 1인 경우 생략 가능**
    - range(stop)
  - [range 함수와 list 관계](https://post.naver.com/viewer/postView.nhn?volumeNo=27735641&memberNo=21815&vType=VERTICAL)

```python
print(list(range(0,10,1))) == print(list(range(10,1))) == print(list(range(10)))
print(list(range(0,-5,1))) #빈 리스트 반환 ; 0부터 1씩 증가해서 -5가 될 수 없음
print(list(range(-10,0,2)))
print(list(range(3,-10,-3)))
>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 []
 [-10, -8, -6, -4, -2]
 [3, 0, -3, -6, -9]
```

5. 중첩 for문

- <반복변수1>의 첫 번째 **데이터 실행될 때** 그 안에 있는 for문을 만나게 되어 **내부 for문을 실행**하고 다시 <반복변수1>의 두 번째 데이터가 실행될 때 for문을 수행
- 중첩 for문을 모두 마치면 코드가 끝남

```python
for <반복 변수1> in <반복범위 1> :

	for<반복변수2> in <반복범위2> : 

		<코드블록>
x_list=['x1','x2']
y_list=['y1','y2']

print("x y")

for x in x_list : 
	for y in y_list : 
        print(x,y)
        
>x y

 x1 y1
 x1 y2
 x2 y1
 x2 y2 
```

6. 여러 개의 리스트 다루기

- 리스트가 여러 개일 경우 <반복 범위>에 이용할 수 없음
- `len()`(리스트,튜플,세트,딕셔너리 항목의 개수(=데이터의 길이)를 반환)와 `range()`이용

```python
names = ['James','Robert','Lisa','Mary']
scores = [95,96,97,94]

for k in range(len(names)) : #k는 항목의 위치 ; 0부터 3까지 1씩 증가
    print(names[k],scores[k])

>James 95
 Robert 96
 Lisa 97
 Mary 94
```

7. zip()함수 이용

- 길이가 같은 리스트가 여러 개 있는 경우 for문 이용 가능
- **같은 길이** 데이터를 하나로 묶어주는 `zip()`이용 
  - 길이가 다른 경우 긴 데이터가 짤림
- <반복 범위>인 zip() 안에 있는 list1, list2의 항목이 **각각 순서대로 동시에** <반복변수>에 대입 후 <코드블록> 실행
- 길이가 같은 여러 개의 리스트를 for문에서 처리할 경우 zip함수 이용시 좀 더 알아보기 용이

`````python
for var1, var2 in zip(list1,list2):
    <코드블록>

for names, scores in zip(names, score):
    print(names,scores)

    
>James 95
 Robert 96
 Lisa 97
 Mary 94
`````



##### 2. 조건에 따라 반복하는 while문

1. 조건에 따라 반복하는 while문

- **조건에 따라 반복 여부를 결정**
- **반복 범위 없이 조건에 따라서 반복 수행 여부를 결정**하는 경우 주로 이용
  - for문 : **반복범위가 정해진 반복**을 수행하는 경우
- <조건문> 만족 시 <코드블록>을 계속 수행, <조건문>을 만족하지 않으면 <코드 블록>을 실행하지 않고while문을 빠져나옴

```python
while <조건문> : 
	<코드 블록>
 
i = 0 # 변수 i와 sum 초기화
sum = 0
print("i sum")

while (sum < 20): #조건 검사
    i = i + 1 #i를 1씩 증가
    sum = sum + 1 #이전의 sum과 현재 i를 더해서 sum을 갱신
    print(i,sum) #i와 sum을 출력
>i sum
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
10 10
11 11
12 12
13 13
14 14
15 15
16 16
17 17
18 18
19 19
20 20 #sum이 20이상이 되자 <코드 블록>을 실행하지 않고 while문을 빠져나옴
```

2. 무한 반복 while문

- while문을 조건이 만족하는 경우에만 수행
- <코드 블록>을 무조건 계속 반복하라고 명력

``` python
while True : #while문에서 <조건문>이 항상 참이므로 코드 블록을 무조건 반복 수행
while True : 
    print("while test")
#while문에서 <조건문>이 항상 참일 경우 <코드 블록>에 있는 코드가 무한 반복하므로 주의가 필요
```

3. 반복문을 제어하는 `break`와 `contine`

- `for문` : <반복 범위> 동안, `while문`:<조건문>을 만족할 때까지 계속해서 <코드 블록>의 코드 실행
- 반복문이 수행되고 있는 동안에 **특정 조건을 만족하는 경우 반복을 멈추고 <코드 블록을>을 빠져나오거나 다음 반복을 수행**하게 하려면?
  -  `break`와 `contine`를 이용
  -  공통점 : 반복문을 빠져나옴

1\) `break`를 이용해 `while문`을 빠져나옴

`````python
k=0
while True : 
    k = k + 1
    if(k>3): #k가 3보다 크면
        break #break로 while문을 빠져나옴
    print(k) #k는 출력
>1
 2
 3 #k가 4가 되는 순간 while문을 빠져나옴
`````

2\) `for문`에서 `break`를 이용한 코드

`````python
for k in range(10):
    if(k>2): # 조건문 ;k>2이면
        break # break로 for문을 빠져나옴
    print(k)  # k 출력
>0
 1
 2
`````

3\) 다음 반복을 실행하는 `continue`

- 반복문 안에서 `continue`를 만나면 **반복문의 처음으로 돌아가서 다음 반복을 진행**

```python
for k in range(5) :
    if(k==2):
        continue
    print(k)
>0
 1
 3
 4 #지정조건 k == 2를 만족해 coutinue가 실행 -> print(k)를 실행하지 않음
```

4\) while문에서 `break`와 `conuinue`를 모두 사용

````python
k = 0
while True : 
    k=K+1
    if(k == 2):
        print('continue next')
        continue
        
    if(k > 4) : 
        break
    print(k)
>0
1
continue next
3
4
````

4. 간단하게 반복하는 한 줄 for문

- **리스트, 세트, 딕셔너리**에서 실행할 수 있는 한 줄 for문도 지원
  - 리스트 컴프리헨션 / 세트 컴프리헨션 / 딕셔너리 컴프리헨션
  - 리스트, 세트, 딕셔너리 내에 코드가 내포돼 실행되는 것을 의미
- 컴프리헨션을 잘 이용하면 **리스트, 세트, 딕셔너리 데이터를 반복해서 처리해야 할 때 편리**

1\) 리스트 컴프리헨션의 기본 구조

`[<반복 실행문> for <반복 변수> in <반복범위> ]`

- <반복 실행문>이 먼저 나왔기 때문에 콜론(:)도 이용하지 않음

````python
numbers = [1,2,3,4,5]
squre = []
for i in numbers : 
    squres.append(i**2)
print(squre)

==

squre=[i**2 for i in numbers] #위 코드보다 좀 더 간단하게 코드를 작성 가능
print(squre)

>[1, 4, 9, 16, 25]
````

- 조건문을 포함한 리스트 컴프리헨션
  - for문 다음에 if <조건문>을 추가할 수 있음

`[<반복 실행문> for <반복 변수> in <반복 범위> if <조건문>]`

- 반복문을 수행하다가 if <조건문>을 만족하는 경우에만 <반복 실행문>을 실행

````python
numbers = [1,2,3,4,5]
squre = []
for i in numbers : 
    if i >= 3 :
        squre.append(i**2)
print(squre)
    
==

squre = [i**2 for i in numbers if i >= 3]
print(squre)

> [9, 16, 25]
````

